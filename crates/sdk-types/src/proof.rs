use std::{collections::BTreeMap, fs::File, path::Path};

use anyhow::{Context, Result};
use serde::{Deserialize, Serialize};
use slop_algebra::AbstractField;
use slop_alloc::{CpuBackend, GLOBAL_CPU_BACKEND};
use slop_basefold::BasefoldProof;
use slop_commit::Rounds;
use slop_jagged::{JaggedPcsProof, JaggedSumcheckEvalProof};
use slop_multilinear::{Mle, MleEval, Point};
use slop_sumcheck::PartialSumcheckProof;
use slop_tensor::Tensor;
use sp1_hypercube::SP1PcsProof;
use sp1_hypercube::{
    LogUpEvaluations, LogUpGkrOutput, LogupGkrProof, MerkleProof, SP1PcsProofInner,
    SP1RecursionProof, ShardOpenedValues, ShardProof, DIGEST_SIZE,
};
use sp1_primitives::{io::SP1PublicValues, SP1ExtensionField, SP1Field, SP1GlobalContext};
use sp1_prover::{Groth16Bn254Proof, HashableKey, PlonkBn254Proof, SP1VerifyingKey};
use sp1_verifier::{ProofFromNetwork, SP1Proof, SP1ProofMode};

/// A proof generated by the SP1 RISC-V zkVM bundled together with the public values and the
/// version.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SP1ProofWithPublicValues {
    /// The raw proof generated by the SP1 RISC-V zkVM.
    pub proof: SP1Proof,
    /// The public values generated by the SP1 RISC-V zkVM.
    pub public_values: SP1PublicValues,
    /// The version of the SP1 RISC-V zkVM.
    pub sp1_version: String,
    /// The integrity proof generated by the TEE server.
    pub tee_proof: Option<Vec<u8>>,
}

impl From<ProofFromNetwork> for SP1ProofWithPublicValues {
    fn from(value: ProofFromNetwork) -> Self {
        Self {
            proof: value.proof,
            public_values: value.public_values,
            sp1_version: value.sp1_version,
            tee_proof: None,
        }
    }
}

impl SP1ProofWithPublicValues {
    /// Creates a new [`SP1ProofWithPublicValues`] from the proof, public values, and SP1 version.
    #[must_use]
    pub const fn new(proof: SP1Proof, public_values: SP1PublicValues, sp1_version: String) -> Self {
        Self { proof, public_values, sp1_version, tee_proof: None }
    }

    /// Saves the proof to a path.
    pub fn save(&self, path: impl AsRef<Path>) -> Result<()> {
        bincode::serialize_into(
            File::create(path.as_ref()).with_context(|| {
                format!("failed to create file for saving proof: {}", path.as_ref().display())
            })?,
            self,
        )
        .map_err(Into::into)
    }

    /// Loads a proof from a path.
    pub fn load(path: impl AsRef<Path>) -> Result<Self> {
        let maybe_this: Result<Self> =
            bincode::deserialize_from(File::open(path.as_ref()).with_context(|| {
                format!("failed to open file for loading proof: {}", path.as_ref().display())
            })?)
            .map_err(Into::into);

        match maybe_this {
            Ok(this) => Ok(this),
            Err(e) => {
                let maybe_proof_from_network: Result<ProofFromNetwork> =
                    bincode::deserialize_from(File::open(path.as_ref()).with_context(|| {
                        format!(
                            "failed to open file for loading proof: {}",
                            path.as_ref().display()
                        )
                    })?)
                    .map_err(Into::into);

                if let Ok(proof_from_network) = maybe_proof_from_network {
                    Ok(proof_from_network.into())
                } else {
                    Err(e)
                }
            }
        }
    }

    /// The proof in the byte encoding the onchain verifiers accepts for [`SP1ProofMode::Groth16`]
    /// and [`SP1ProofMode::Plonk`] proofs.
    #[must_use]
    pub fn bytes(&self) -> Vec<u8> {
        match &self.proof {
            SP1Proof::Plonk(plonk_proof) => {
                if plonk_proof.encoded_proof.is_empty() {
                    return Vec::new();
                }

                let proof_bytes =
                    hex::decode(&plonk_proof.encoded_proof).expect("Invalid Plonk proof");

                if let Some(tee_proof) = &self.tee_proof {
                    return [
                        tee_proof.clone(),
                        plonk_proof.plonk_vkey_hash[..4].to_vec(),
                        proof_bytes,
                    ]
                    .concat();
                }

                [plonk_proof.plonk_vkey_hash[..4].to_vec(), proof_bytes].concat()
            }
            SP1Proof::Groth16(groth16_proof) => {
                if groth16_proof.encoded_proof.is_empty() {
                    return Vec::new();
                }

                let proof_bytes =
                    hex::decode(&groth16_proof.encoded_proof).expect("Invalid Groth16 proof");

                if let Some(tee_proof) = &self.tee_proof {
                    return [
                        tee_proof.clone(),
                        groth16_proof.groth16_vkey_hash[..4].to_vec(),
                        proof_bytes,
                    ]
                    .concat();
                }

                [groth16_proof.groth16_vkey_hash[..4].to_vec(), proof_bytes].concat()
            }
            proof => panic!(
                "Proof type {proof} is not supported for onchain verification. \
                Only Plonk and Groth16 proofs are verifiable onchain"
            ),
        }
    }

    /// Creates a mock proof for the specified proof mode from the public values.
    ///
    /// # Example
    /// ```rust,no_run
    /// use sp1_primitives::io::SP1PublicValues;
    /// use sp1_sdk_types::{Elf, SP1ProofMode, SP1ProofWithPublicValues, SP1_CIRCUIT_VERSION};
    ///
    /// tokio_test::block_on(async {
    ///     let elf = Elf::Static(&[1, 2, 3]);
    ///
    ///     let node = sp1_prover::worker::SP1LightNode::new().await;
    ///     let vk = node.setup(&elf).await.unwrap();
    ///     let public_values = SP1PublicValues::default();
    ///
    ///     // Create a mock Plonk proof.
    ///     let mock_proof = SP1ProofWithPublicValues::create_mock_proof(
    ///         &vk,
    ///         public_values,
    ///         SP1ProofMode::Plonk,
    ///         SP1_CIRCUIT_VERSION,
    ///     );
    /// });
    /// ```
    #[must_use]
    #[allow(clippy::needless_pass_by_value)]
    pub fn create_mock_proof(
        vk: &SP1VerifyingKey,
        public_values: SP1PublicValues,
        mode: SP1ProofMode,
        sp1_version: &str,
    ) -> Self {
        let sp1_version = sp1_version.to_string();
        match mode {
            SP1ProofMode::Core => SP1ProofWithPublicValues {
                proof: SP1Proof::Core(vec![]),
                public_values,
                sp1_version,
                tee_proof: None,
            },
            SP1ProofMode::Compressed => {
                // Create a mock compressed proof with dummy values.
                let dummy_proof = create_dummy_recursion_proof(vk);
                SP1ProofWithPublicValues {
                    proof: SP1Proof::Compressed(Box::new(dummy_proof)),
                    public_values,
                    sp1_version,
                    tee_proof: None,
                }
            }
            SP1ProofMode::Plonk => {
                // Create mock Plonk proof with correct public inputs.
                // public_inputs[0]: vkey_hash
                // public_inputs[1]: committed_values_digest (public_values hash)
                // public_inputs[2]: exit_code (0 for success)
                // public_inputs[3]: vk_root (0 for mock)
                // public_inputs[4]: proof_nonce (0 for mock)
                let vkey_hash = vk.hash_bn254().to_string();
                let committed_values_digest = public_values.hash_bn254().to_string();
                SP1ProofWithPublicValues {
                    proof: SP1Proof::Plonk(PlonkBn254Proof {
                        public_inputs: [
                            vkey_hash,
                            committed_values_digest,
                            "0".to_string(), // exit_code
                            "0".to_string(), // vk_root (mock)
                            "0".to_string(), // proof_nonce (mock)
                        ],
                        encoded_proof: String::new(),
                        raw_proof: String::new(),
                        plonk_vkey_hash: [0; 32],
                    }),
                    public_values,
                    sp1_version,
                    tee_proof: None,
                }
            }
            SP1ProofMode::Groth16 => {
                // Create mock Groth16 proof with correct public inputs.
                // public_inputs[0]: vkey_hash
                // public_inputs[1]: committed_values_digest (public_values hash)
                // public_inputs[2]: exit_code (0 for success)
                // public_inputs[3]: vk_root (0 for mock)
                // public_inputs[4]: proof_nonce (0 for mock)
                let vkey_hash = vk.hash_bn254().to_string();
                let committed_values_digest = public_values.hash_bn254().to_string();
                SP1ProofWithPublicValues {
                    proof: SP1Proof::Groth16(Groth16Bn254Proof {
                        public_inputs: [
                            vkey_hash,
                            committed_values_digest,
                            "0".to_string(), // exit_code
                            "0".to_string(), // vk_root (mock)
                            "0".to_string(), // proof_nonce (mock)
                        ],
                        encoded_proof: String::new(),
                        raw_proof: String::new(),
                        groth16_vkey_hash: [0; 32],
                    }),
                    public_values,
                    sp1_version,
                    tee_proof: None,
                }
            }
        }
    }
}

/// Creates a dummy recursion proof with minimal values for mock proof creation.
fn create_dummy_recursion_proof(
    vk: &SP1VerifyingKey,
) -> SP1RecursionProof<SP1GlobalContext, SP1PcsProofInner> {
    let dummy_query_proof = Vec::new();
    let basefold_proof = BasefoldProof::<SP1GlobalContext> {
        univariate_messages: vec![],
        fri_commitments: vec![],
        final_poly: SP1ExtensionField::zero(),
        pow_witness: SP1Field::zero(),
        component_polynomials_query_openings_and_proofs: vec![],
        query_phase_openings_and_proofs: dummy_query_proof,
    };

    let batch_evaluations: Rounds<MleEval<SP1ExtensionField, CpuBackend>> = Rounds::default();

    let stacked_proof = SP1PcsProof { basefold_proof, batch_evaluations };

    let jagged_eval_proof =
        JaggedSumcheckEvalProof { partial_sumcheck_proof: PartialSumcheckProof::dummy() };

    let evaluation_proof = JaggedPcsProof {
        pcs_proof: stacked_proof,
        jagged_eval_proof,
        sumcheck_proof: PartialSumcheckProof::dummy(),
        merkle_tree_commitments: Rounds::default(),
        row_counts_and_column_counts: Rounds::default(),
        expected_eval: SP1ExtensionField::zero(),
        max_log_row_count: 1,
        log_m: 1,
    };

    let empty_tensor: Tensor<SP1ExtensionField, CpuBackend> =
        Tensor::zeros_in([1], GLOBAL_CPU_BACKEND);
    let logup_gkr_proof = LogupGkrProof {
        circuit_output: LogUpGkrOutput {
            numerator: Mle::new(empty_tensor.clone()),
            denominator: Mle::new(empty_tensor),
        },
        round_proofs: vec![],
        logup_evaluations: LogUpEvaluations {
            point: Point::from_usize(0, 1),
            chip_openings: BTreeMap::new(),
        },
        witness: SP1Field::zero(),
    };

    let dummy_shard_proof = ShardProof {
        public_values: Vec::new(),
        main_commitment: [SP1Field::zero(); DIGEST_SIZE],
        logup_gkr_proof,
        zerocheck_proof: PartialSumcheckProof::dummy(),
        opened_values: ShardOpenedValues { chips: BTreeMap::new() },
        evaluation_proof,
    };

    SP1RecursionProof {
        vk: vk.vk.clone(),
        proof: dummy_shard_proof,
        vk_merkle_proof: MerkleProof { index: 0, path: vec![] },
    }
}
